 src/map/ai/helpers/targetfind.cpp | 10 ++++++++++
 src/map/entities/charentity.cpp   |  5 +++++
 src/map/lua/lua_zone.cpp          | 22 ++++++++++++++++++++--
 src/map/lua/luautils.cpp          |  1 +
 src/map/utils/battleutils.cpp     | 10 ++++++++++
 src/map/zone.cpp                  | 15 +++++++++++++--
 6 files changed, 59 insertions(+), 4 deletions(-)

diff --git a/src/map/ai/helpers/targetfind.cpp b/src/map/ai/helpers/targetfind.cpp
index 16e52fd4ba..71e4943d6a 100644
--- a/src/map/ai/helpers/targetfind.cpp
+++ b/src/map/ai/helpers/targetfind.cpp
@@ -34,6 +34,7 @@ along with this program.  If not, see http://www.gnu.org/licenses/
 #include <cmath>
 
 #include "../../packets/action.h"
+#include "../../treasure_pool.h"
 
 CTargetFind::CTargetFind(CBattleEntity* PBattleEntity)
 {
@@ -359,6 +360,15 @@ bool CTargetFind::isMobOwner(CBattleEntity* PTarget)
         return true;
     }
 
+    if (m_PBattleEntity->objtype == TYPE_PC)
+    {
+        CCharEntity* PChar = static_cast<CCharEntity*>(m_PBattleEntity);
+        if (PChar->PTreasurePool != nullptr && PChar->PTreasurePool->GetPoolType() == TREASUREPOOL_ZONE)
+        {
+            return true;
+        }
+    }
+    
     bool found = false;
 
     m_PBattleEntity->ForAlliance([&found, &PTarget](CBattleEntity* PMember) {
diff --git a/src/map/entities/charentity.cpp b/src/map/entities/charentity.cpp
index abebfbd4b5..d92b979ab2 100644
--- a/src/map/entities/charentity.cpp
+++ b/src/map/entities/charentity.cpp
@@ -1601,6 +1601,11 @@ bool CCharEntity::IsMobOwner(CBattleEntity* PBattleTarget)
         return true;
     }
 
+    if (PTreasurePool != nullptr && PTreasurePool->GetPoolType() == TREASUREPOOL_ZONE)
+    {
+        return true;
+    }
+
     bool found = false;
 
     ForAlliance([&PBattleTarget, &found](CBattleEntity* PEntity) {
diff --git a/src/map/lua/lua_zone.cpp b/src/map/lua/lua_zone.cpp
index 00355ed6d8..8c521b16e0 100644
--- a/src/map/lua/lua_zone.cpp
+++ b/src/map/lua/lua_zone.cpp
@@ -260,15 +260,33 @@ std::optional<CLuaBaseEntity> CLuaZone::insertDynamicEntity(sol::table table)
     else if (auto* PMob = dynamic_cast<CMobEntity*>(PEntity))
     {
         // Ensure mobs get a function for onMobDeath
+
+        auto onMobSpawn = table["onMobSpawn"].get_or<sol::function>(sol::lua_nil);
+        if (onMobSpawn.valid())
+        {
+            cacheEntry["onMobSpawn"] = onMobSpawn;
+        }
+        else
+        {
+            cacheEntry["onMobSpawn"] = []() {}; // Empty func
+        }
+
+        auto onMobFight = table["onMobFight"].get_or<sol::function>(sol::lua_nil);
+        if (onMobFight.valid())
+        {
+            cacheEntry["onMobFight"] = onMobFight;
+        }
+        else
+        {
+            cacheEntry["onMobFight"] = []() {}; // Empty func
+        }
         auto onMobDeath = table["onMobDeath"].get_or<sol::function>(sol::lua_nil);
         if (!onMobDeath.valid())
         {
             cacheEntry["onMobDeath"] = [](){}; // Empty func
         }
-
         m_pLuaZone->InsertMOB(PMob);
     }
-
     if (table["look"].get_type() == sol::type::number)
     {
         PEntity->SetModelId(table.get<uint16>("look"));
diff --git a/src/map/lua/luautils.cpp b/src/map/lua/luautils.cpp
index 80cf15bafc..3f7ea81b44 100644
--- a/src/map/lua/luautils.cpp
+++ b/src/map/lua/luautils.cpp
@@ -1647,6 +1647,7 @@ namespace luautils
         auto filename = fmt::format("./scripts/zones/{}/Zone.lua", name);
 
         auto onZoneTick = GetCacheEntryFromFilename(filename)["onZoneTick"];
+
         if (!onZoneTick.valid())
         {
             return;
diff --git a/src/map/utils/battleutils.cpp b/src/map/utils/battleutils.cpp
index d7b193fefe..ccc65532b5 100644
--- a/src/map/utils/battleutils.cpp
+++ b/src/map/utils/battleutils.cpp
@@ -74,6 +74,7 @@
 #include "battleutils.h"
 #include "charutils.h"
 #include "zoneutils.h"
+#include "../treasure_pool.h"
 
 /************************************************************************
 *   lists used in battleutils                                           *
@@ -6109,6 +6110,15 @@ namespace battleutils
             return true;
         }
 
+        if (PEntity->objtype == TYPE_PC) 
+        {
+            CCharEntity* PChar = static_cast<CCharEntity*>(PEntity);
+            if (PChar->PTreasurePool != nullptr && PChar->PTreasurePool->GetPoolType() == TREASUREPOOL_ZONE)
+            {
+                return true;
+            }
+        }
+        
         bool found = false;
 
         // clang-format off
diff --git a/src/map/zone.cpp b/src/map/zone.cpp
index 761f6e4826..76773b7493 100644
--- a/src/map/zone.cpp
+++ b/src/map/zone.cpp
@@ -986,8 +986,19 @@ void CZone::CharZoneIn(CCharEntity* PChar)
     }
     else
     {
-        PChar->PTreasurePool = new CTreasurePool(TREASUREPOOL_SOLO);
-        PChar->PTreasurePool->AddMember(PChar);
+//        PChar->PTreasurePool = new CTreasurePool(TREASUREPOOL_SOLO);
+//        PChar->PTreasurePool->AddMember(PChar);
+            if (m_TreasurePool != nullptr)
+        {
+            PChar->PTreasurePool = m_TreasurePool;
+            PChar->PTreasurePool->AddMember(PChar);
+            
+        }
+        else
+        {
+            PChar->PTreasurePool = new CTreasurePool(TREASUREPOOL_SOLO);
+            PChar->PTreasurePool->AddMember(PChar);
+        }
     }
 
     if (m_zoneType != ZONE_TYPE::DUNGEON_INSTANCED)
